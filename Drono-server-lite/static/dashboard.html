<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drono Lite Control Dashboard</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: #1a73e8;
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        #deviceList {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: flex-start;
        }
        
        .device-card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 0;
            overflow: hidden;
            transition: box-shadow 0.3s;
            flex: 0 0 calc(25% - 12px);
            min-width: 240px;
        }
        
        @media (max-width: 1400px) {
            .device-card {
                flex: 0 0 calc(33.33% - 12px);
            }
        }
        
        @media (max-width: 1100px) {
            .device-card {
                flex: 0 0 calc(50% - 12px);
            }
        }
        
        @media (max-width: 900px) {
            .device-card {
                flex: 0 0 calc(50% - 12px);
            }
        }
        
        @media (max-width: 600px) {
            .device-card {
                flex: 0 0 100%;
            }
        }
        
        .device-card:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }
        
        .device-header {
            background-color: #f5f5f5;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .device-header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .device-header h3 {
            margin: 0;
            font-size: 15px;
            font-weight: 500;
            color: #333;
        }
        
        .device-id {
            font-size: 12px;
            font-weight: normal;
            color: #666;
            margin-left: 8px;
        }
        
        .device-indicators {
            display: flex;
            gap: 6px;
            font-size: 11px;
        }
        
        .indicator {
            font-size: 11px;
            font-weight: 500;
            padding: 3px 6px;
            border-radius: 10px;
            display: inline-block;
        }
        
        .indicator.root {
            background-color: #4caf50;
            color: white;
        }
        
        .indicator.no-root {
            background-color: #f44336;
            color: white;
        }
        
        .indicator.write {
            background-color: #2196f3;
            color: white;
        }
        
        .indicator.no-write {
            background-color: #ff9800;
            color: white;
        }
        
        .indicator.battery {
            background-color: #9e9e9e;
            color: white;
        }
        
        .device-actions {
            padding: 12px 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .action-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .btn {
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: #1557b0;
        }
        
        .device-details {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .device-detail {
            background-color: #f0f4f8;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .device-status {
            padding: 16px;
            font-size: 13px;
        }
        
        .device-status h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .status-running {
            color: #4caf50;
            font-weight: bold;
        }
        
        .status-paused {
            color: #ff9800;
            font-weight: bold;
        }
        
        .status-stopped {
            color: #f44336;
            font-weight: bold;
        }
        
        .status-idle {
            color: #9e9e9e;
            font-weight: bold;
        }
        
        .status-info {
            font-size: 13px;
            color: #555;
            line-height: 1.4;
        }
        
        .status-info > div {
            margin-bottom: 6px;
        }
        
        .progress-bar-container {
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4caf50;
            border-radius: 4px;
            transition: width 0.5s ease-in-out;
        }
        
        .progress-bar.paused {
            background-color: #ff9800;
        }
        
        .progress-percentage {
            position: absolute;
            right: 5px;
            top: -7px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }
        
        .progress-details {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .simulation-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
            margin-bottom: 10px;
        }
        
        .stat-item {
            background-color: #f5f7fa;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid #1a73e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-item.elapsed {
            border-left-color: #4caf50;
        }
        
        .stat-item.remaining {
            border-left-color: #ff9800;
        }
        
        .stat-item.url {
            border-left-color: #2196f3;
            grid-column: span 2;
        }
        
        .stat-item.iterations {
            border-left-color: #9c27b0;
            grid-column: span 2;
        }
        
        .stat-item.interval {
            border-left-color: #9c27b0;
        }
        
        .stat-item.delay {
            border-left-color: #9c27b0;
        }
        
        .stat-label {
            font-weight: bold;
            color: #555;
            font-size: 11px;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 12px;
            color: #333;
            word-break: break-word;
            font-weight: 500;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .url-value {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-group.half {
            flex: 1;
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: #1a73e8;
        }
        
        .device-status {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 12px;
            display: inline-block;
        }
        
        .device-status.online {
            background-color: #e6f4ea;
            color: #137333;
        }
        
        .device-status.offline {
            background-color: #fce8e6;
            color: #c5221f;
        }

        .footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            color: #5f6368;
            font-size: 13px;
        }

        #log {
            background-color: #292929;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .error {
            color: #ea4335;
        }

        .success {
            color: #34a853;
        }

        .info {
            color: #1a73e8;
        }
        
        .warning {
            color: #fbbc04;
        }

        .device-access {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .access-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
        }

        .access-badge.write {
            background-color: #e6f4ea;
            color: #137333;
        }

        .access-badge.root {
            background-color: #fef7e0;
            color: #e37400;
        }

        .access-badge.limited {
            background-color: #fce8e6;
            color: #c5221f;
        }

        .toggle-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #1a73e8;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            margin-left: 10px;
            font-size: 14px;
        }
        
        /* Device selection styles */
        .device-selection {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .device-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .device-card.selected {
            border-left: 4px solid #1a73e8;
        }
        
        .selection-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .selection-actions {
            display: flex;
            gap: 10px;
        }
        
        .selection-count {
            font-weight: bold;
            color: #1a73e8;
            padding: 5px 10px;
            background-color: #e8f0fe;
            border-radius: 4px;
        }
        
        .select-all-checkbox {
            margin-right: 5px;
        }

        .log-controls {
            margin-bottom: 10px;
        }

        .logging-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logging-select {
            padding: 5px;
            border: 1px solid #dadce0;
            border-radius: 4px;
        }

        .setLoggingBtn {
            padding: 5px 10px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .setLoggingBtn:hover {
            background-color: #1557b0;
        }

        /* Add styles for update controls */
        .status-update-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px 12px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        
        .update-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .update-interval-select {
            padding: 4px 6px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .last-update-time {
            font-size: 12px;
            color: #666;
        }
        
        #manualUpdateBtn {
            background-color: #4caf50;
        }
        
        #manualUpdateBtn:hover {
            background-color: #45a049;
        }

        /* SMS actions styling */
        .sms-actions {
            padding: 16px;
            border-top: 1px solid #e0e0e0;
            margin-top: 15px;
        }
        
        .sms-actions h4 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 14px;
            color: #333;
            font-weight: 600;
        }
        
        .sms-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .sms-form input {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            width: 100%;
        }
        
        .sms-buttons {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }
        
        .btn-sms {
            background-color: #4caf50;
            flex: 1;
        }
        
        .btn-sms:hover {
            background-color: #388e3c;
        }
        
        .btn-renew {
            background-color: #ff9800;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .btn-renew:hover {
            background-color: #f57c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>Drono Lite Control Dashboard</h1>
            <p>Control panel for managing Android devices running IMadeThatBitchFamous app</p>
            <button id="refreshDevicesBtn">Refresh Devices</button>
        </div>
        
        <div class="card">
            <h2>URL Distribution</h2>
            <form id="urlDistributionForm">
                <div class="form-group">
                    <label for="targetUrl">Target URL:</label>
                    <input type="text" id="targetUrl" name="targetUrl" placeholder="https://example.com" required>
                </div>
                
                <div class="form-group">
                    <label for="iterations">Iterations:</label>
                    <input type="number" id="iterations" name="iterations" min="1" value="100">
                </div>
                
                <div class="form-row">
                    <div class="form-group half">
                        <label for="minInterval">Min Interval (sec):</label>
                        <input type="number" id="minInterval" name="minInterval" min="1" value="1">
                    </div>
                    
                    <div class="form-group half">
                        <label for="maxInterval">Max Interval (sec):</label>
                        <input type="number" id="maxInterval" name="maxInterval" min="1" value="2">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group half">
                        <label for="delayMin">Delay Min (sec):</label>
                        <input type="number" id="delayMin" name="delayMin" min="0" value="1">
                    </div>
                    
                    <div class="form-group half">
                        <label for="delayMax">Delay Max (sec):</label>
                        <input type="number" id="delayMax" name="delayMax" min="0" value="2">
                    </div>
                </div>
                
                <div class="toggle-group">
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useWebview" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Use WebView Mode</span>
                    </div>
                    
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="rotateIp" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Rotate IP</span>
                    </div>
                    
                    <div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="selectedDevicesOnly">
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Selected Devices Only</span>
                    </div>
                </div>
                
                <button type="submit">Distribute URL</button>
            </form>
        </div>
        
        <div class="card">
            <h2>Connected Devices</h2>
            <div class="selection-controls">
                <div>
                    <label>
                        <input type="checkbox" id="selectAllDevices" class="select-all-checkbox">
                        Select All
                    </label>
                </div>
                <div class="selection-count" id="selectionCount">0 devices selected</div>
                <div class="selection-actions">
                    <button id="startSelectedBtn" class="btn" disabled>Start Selected</button>
                    <button id="stopSelectedBtn" class="btn" disabled>Stop Selected</button>
                    <button id="pauseSelectedBtn" class="btn" disabled>Pause Selected</button>
                    <button id="resumeSelectedBtn" class="btn" disabled>Resume Selected</button>
                </div>
            </div>
            
            <!-- Add status update controls -->
            <div class="status-update-controls">
                <div class="update-toggle">
                    <label>
                        <input type="checkbox" id="autoUpdateToggle">
                        Auto Update
                    </label>
                    <select id="updateIntervalSelect" class="update-interval-select">
                        <option value="5">5 seconds</option>
                        <option value="30">30 seconds</option>
                        <option value="60">1 minute</option>
                        <option value="300">5 minutes</option>
                        <option value="900">15 minutes</option>
                        <option value="1800">30 minutes</option>
                        <option value="3600" selected>1 hour</option>
                    </select>
                </div>
                <button id="refreshStatusBtn" class="btn refresh-btn">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
            
            <div id="deviceList">
                <p>Loading devices...</p>
            </div>
        </div>
        
        <div class="card">
            <h2>Activity Log</h2>
            <div class="log-controls">
                <div class="logging-toggle">
                    <label>Server Log Level:</label>
                    <select id="loggingLevel" class="logging-select">
                        <option value="INFO">INFO</option>
                        <option value="DEBUG">DEBUG</option>
                        <option value="WARNING">WARNING</option>
                        <option value="ERROR">ERROR</option>
                        <option value="CRITICAL">CRITICAL</option>
                    </select>
                    <button id="setLoggingBtn" class="btn">Apply</button>
                    <label>
                        <input type="checkbox" id="quietAdbMode"> 
                        Quiet ADB Mode
                    </label>
                </div>
            </div>
            <div id="log"></div>
        </div>
        
        <div class="footer">
            Drono Lite Control Server &copy; 2023
        </div>
    </div>
    
    <script>
        const API_URL = window.location.origin;
        let socket;
        let devices = [];
        let isWebSocketConnected = false;
        
        // Initialize WebSocket connection
        function connectWebSocket() {
            socket = new WebSocket(`ws://${window.location.host}/ws/dashboard`);
            
            socket.onopen = function(e) {
                log('WebSocket connection established', 'success');
                isWebSocketConnected = true;
                
                // After connection, get initial device list
                getDevices();
            };
            
            socket.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    
                    // Handle different message types
                    switch(message.type) {
                        case 'device_list':
                            updateDeviceList(message.data.devices);
                            break;
                        case 'command_result':
                            handleCommandResult(message.data);
                            // After a command, request updated status
                            if (message.data.device_id) {
                                socket.send(JSON.stringify({
                                    type: 'get_device_status',
                                    device_id: message.data.device_id
                                }));
                            }
                            break;
                        case 'url_distribution':
                            handleUrlDistributionResult(message.data);
                            break;
                        case 'batch_command_result':
                            handleBatchCommandResult(message.data);
                            // Request updated status for all devices after batch command
                            requestAllDeviceStatuses();
                            break;
                        case 'status_update':
                            if (message.data.devices_status) {
                                // Check if this is a partial update
                                const isPartial = message.data.is_partial || false;
                                
                                if (isPartial) {
                                    // For partial updates, only update the specified devices
                                    updateDeviceStatus(message.data.devices_status);
                                } else {
                                    // For full updates, update all devices and clear any not included
                                    updateDeviceStatus(message.data.devices_status, false);
                                }
                                updateLastUpdateTime();
                            }
                            break;
                        case 'status_update_config':
                            // Update UI to match new settings from server
                            if (message.data) {
                                document.getElementById('autoUpdateToggle').checked = message.data.automatic;
                                document.getElementById('updateIntervalSelect').value = message.data.interval.toString();
                                log(`Status update settings changed: automatic=${message.data.automatic}, interval=${formatInterval(message.data.interval)}`, 'info');
                            }
                            break;
                        case 'device_status':
                            if (message.data.device_id && message.data.status) {
                                updateSingleDeviceStatus(message.data.device_id, message.data.status);
                            } else if (message.data.status) {
                                updateSingleDeviceStatus(message.data.device_id || "unknown", message.data.status);
                            }
                            break;
                        case 'logging_configured':
                            // Handle logging configuration broadcast
                            if (message.data) {
                                log(`Logging level changed: ${message.data.message}`, 'info');
                                // Update UI to match new settings
                                getLoggingStatus();
                            }
                            break;
                        default:
                            log(`Unknown message type: ${message.type}`, 'warning');
                    }
                } catch (error) {
                    log(`Error parsing WebSocket message: ${error}`, 'error');
                }
            };
            
            socket.onclose = function(event) {
                log('WebSocket connection closed, reconnecting...', 'warning');
                isWebSocketConnected = false;
                
                // Try to reconnect in 3 seconds
                setTimeout(connectWebSocket, 3000);
            };
            
            socket.onerror = function(error) {
                log(`WebSocket error: ${error}`, 'error');
                isWebSocketConnected = false;
            };
        }
        
        // Get list of connected devices
        async function getDevices() {
            try {
                if (isWebSocketConnected) {
                    // If WebSocket is connected, use it to request device scan
                    socket.send(JSON.stringify({
                        type: 'scan_devices'
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/devices`);
                    const data = await response.json();
                    updateDeviceList(data.devices);
                }
            } catch (error) {
                log(`Error fetching devices: ${error}`, 'error');
            }
        }
        
        // Update device list UI
        function updateDeviceList(deviceList) {
            devices = deviceList;
            const deviceListElement = document.getElementById('deviceList');
            
            if (devices.length === 0) {
                deviceListElement.innerHTML = '<p>No devices connected</p>';
                updateSelectionCount();
                return;
            }
            
            deviceListElement.innerHTML = '';
            
            devices.forEach(device => {
                const deviceCard = document.createElement('div');
                deviceCard.className = 'device-card';
                deviceCard.id = `device-${device.id}`;
                deviceCard.dataset.deviceId = device.id;
                
                // Access indicators
                const rootIndicator = device.has_root_access ? 
                    '<span class="indicator root">ROOT</span>' : 
                    '<span class="indicator no-root">NO ROOT</span>';
                    
                const writeIndicator = device.has_write_access ? 
                    '<span class="indicator write">WRITE</span>' : 
                    '<span class="indicator no-write">NO WRITE</span>';
                
                deviceCard.innerHTML = `
                    <div class="device-header">
                        <div class="device-header-main">
                            <h3>
                                <label class="device-selection">
                                    <input type="checkbox" class="device-checkbox" data-device-id="${device.id}" onchange="handleDeviceSelection(this)">
                                    ${device.model} <span class="device-id">${device.id}</span>
                                </label>
                            </h3>
                            <span class="indicator battery">${device.battery}</span>
                        </div>
                        <div class="device-indicators">
                            ${rootIndicator}
                            ${writeIndicator}
                        </div>
                    </div>
                    <div class="device-actions">
                        <div class="action-group">
                            <button class="btn" onclick="executeCommand('${device.id}', 'start')">Start</button>
                            <button class="btn" onclick="executeCommand('${device.id}', 'stop')">Stop</button>
                            <button class="btn" onclick="executeCommand('${device.id}', 'pause')">Pause</button>
                            <button class="btn" onclick="executeCommand('${device.id}', 'resume')">Resume</button>
                        </div>
                    </div>
                    <div class="device-status">
                        <h3>Simulation Status <span class="status-idle">⚪ LOADING</span></h3>
                        <div class="status-info">
                            <div>Loading simulation data...</div>
                            <div class="simulation-stats">
                                <div class="stat-item elapsed">
                                    <div class="stat-label">ELAPSED</div>
                                    <div class="stat-value">-</div>
                                </div>
                                <div class="stat-item remaining">
                                    <div class="stat-label">REMAINING</div>
                                    <div class="stat-value">-</div>
                                </div>
                                <div class="stat-item iterations">
                                    <div class="stat-label">PROGRESS</div>
                                    <div class="stat-value">-</div>
                                </div>
                                <div class="stat-item interval">
                                    <div class="stat-label">INTERVAL</div>
                                    <div class="stat-value">0-0s</div>
                                </div>
                                <div class="stat-item delay">
                                    <div class="stat-label">DELAY</div>
                                    <div class="stat-value">1-2s</div>
                                </div>
                                <div class="stat-item url">
                                    <div class="stat-label">URL</div>
                                    <div class="stat-value">-</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sms-actions">
                        <h4>SMS Actions</h4>
                        <button class="btn btn-renew" onclick="sendDataRenewalSMS('${device.id}')">Open Messages & Send "DN" to 950</button>
                        <div class="sms-form">
                            <input type="tel" placeholder="Phone number" class="sms-number" id="sms-number-${device.id}">
                            <input type="text" placeholder="Message" class="sms-message" id="sms-message-${device.id}">
                            <div class="sms-buttons">
                                <button class="btn btn-sms" onclick="sendCustomSMS('${device.id}')">Open Messages & Send</button>
                            </div>
                        </div>
                    </div>
                `;
                
                deviceListElement.appendChild(deviceCard);
                
                // Request status for this device
                if (isWebSocketConnected) {
                    socket.send(JSON.stringify({
                        type: 'get_device_status',
                        device_id: device.id
                    }));
                }
            });
            
            updateSelectionCount();
            log(`Found ${devices.length} device(s)`, 'info');
        }
        
        // Execute command on specific device
        async function executeCommand(deviceId, command) {
            log(`Executing command '${command}' on device ${deviceId}...`, 'info');
            
            // Get URL and other parameters if command is start
            let params = {};
            if (command === 'start') {
                const targetUrl = document.getElementById('targetUrl').value;
                const iterations = parseInt(document.getElementById('iterations').value);
                const minInterval = parseInt(document.getElementById('minInterval').value);
                const maxInterval = parseInt(document.getElementById('maxInterval').value);
                const delayMin = parseInt(document.getElementById('delayMin').value || "1");
                const delayMax = parseInt(document.getElementById('delayMax').value || "2");
                const useWebview = document.getElementById('useWebview').checked;
                const rotateIp = document.getElementById('rotateIp').checked;
                
                params = {
                    url: targetUrl,
                    iterations: iterations,
                    min_interval: minInterval,
                    max_interval: maxInterval,
                    delay_min: delayMin,
                    delay_max: delayMax,
                    use_webview: useWebview,
                    rotate_ip: rotateIp
                };
            }
            
            try {
                if (isWebSocketConnected) {
                    // Use WebSocket for commands
                    socket.send(JSON.stringify({
                        type: 'execute_command',
                        device_id: deviceId,
                        command: command,
                        parameters: params
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/devices/${deviceId}/command`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            command: command,
                            parameters: params
                        })
                    });
                    
                    const result = await response.json();
                    handleCommandResult({
                        device_id: deviceId,
                        command: command,
                        result: result
                    });
                }
            } catch (error) {
                log(`Error executing command: ${error}`, 'error');
            }
        }
        
        // Handle command result
        function handleCommandResult(data) {
            const { device_id, command, result } = data;
            
            if (result.success) {
                log(`Command '${command}' successful on device ${device_id}`, 'success');
            } else {
                log(`Command '${command}' failed on device ${device_id}: ${result.error || 'Unknown error'}`, 'error');
            }
        }
        
        // Handle URL distribution result
        function handleUrlDistributionResult(data) {
            const { url, devices, results } = data;
            
            if (!devices || devices.length === 0 || !results || Object.keys(results).length === 0) {
                log(`URL distribution request for '${url}' received, but no results returned`, 'warning');
                return;
            }
            
            const successCount = Object.values(results).filter(r => r && r.success).length;
            const totalCount = devices.length;
            
            log(`URL distribution completed: ${successCount}/${totalCount} devices successful`, 
                successCount === totalCount ? 'success' : successCount > 0 ? 'warning' : 'error');
            
            // Log failures individually
            if (successCount < totalCount) {
                for (const [deviceId, result] of Object.entries(results)) {
                    if (!result || !result.success) {
                        log(`URL distribution failed on device ${deviceId}: ${result?.error || 'Unknown error'}`, 'error');
                    }
                }
            }
            
            // Request updated statuses after a short delay
            setTimeout(requestAllDeviceStatuses, 1000);
        }
        
        // Handle batch command result
        function handleBatchCommandResult(data) {
            const { command, results } = data;
            
            if (!results || Object.keys(results).length === 0) {
                log(`Batch command '${command}' executed, but no results were returned`, 'warning');
                return;
            }
            
            const successCount = Object.values(results).filter(r => r && r.success).length;
            const totalCount = Object.keys(results).length;
            
            log(`Batch command '${command}' completed: ${successCount}/${totalCount} successful`, 
                successCount === totalCount ? 'success' : successCount > 0 ? 'warning' : 'error');
            
            // Log individual results if there were failures
            if (successCount < totalCount) {
                for (const [deviceId, result] of Object.entries(results)) {
                    if (!result || !result.success) {
                        log(`Failed on device ${deviceId}: ${result?.error || 'Unknown error'}`, 'error');
                    }
                }
            }
            
            // Request updated statuses after a short delay to allow the commands to take effect
            setTimeout(requestAllDeviceStatuses, 500);
        }
        
        // Distribute URL to devices
        async function distributeUrl(event) {
            event.preventDefault();
            
            const targetUrl = document.getElementById('targetUrl').value;
            if (!targetUrl) {
                log('Error: Target URL is required', 'error');
                return;
            }
            
            const iterations = parseInt(document.getElementById('iterations').value);
            const minInterval = parseInt(document.getElementById('minInterval').value);
            const maxInterval = parseInt(document.getElementById('maxInterval').value);
            const delayMin = parseInt(document.getElementById('delayMin').value || "1");
            const delayMax = parseInt(document.getElementById('delayMax').value || "2");
            const useWebview = document.getElementById('useWebview').checked;
            const rotateIp = document.getElementById('rotateIp').checked;
            const selectedDevicesOnly = document.getElementById('selectedDevicesOnly').checked;
            
            // Get device IDs based on selection
            let targetDeviceIds = null; // null means all devices
            if (selectedDevicesOnly) {
                targetDeviceIds = getSelectedDeviceIds();
                if (targetDeviceIds.length === 0) {
                    log('No devices selected. Select devices or uncheck "Selected Devices Only"', 'warning');
                    return;
                }
                log(`Distributing URL '${targetUrl}' to ${targetDeviceIds.length} selected devices...`, 'info');
            } else {
                log(`Distributing URL '${targetUrl}' to all connected devices...`, 'info');
            }
            
            try {
                if (isWebSocketConnected) {
                    // Use WebSocket
                    socket.send(JSON.stringify({
                        type: 'distribute_url',
                        url: targetUrl,
                        device_ids: targetDeviceIds,
                        iterations: iterations,
                        min_interval: minInterval,
                        max_interval: maxInterval,
                        delay_min: delayMin,
                        delay_max: delayMax,
                        use_webview: useWebview,
                        rotate_ip: rotateIp
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/distribute-url`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            url: targetUrl,
                            device_ids: targetDeviceIds,
                            iterations: iterations,
                            min_interval: minInterval,
                            max_interval: maxInterval,
                            delay_min: delayMin,
                            delay_max: delayMax,
                            use_webview: useWebview,
                            rotate_ip: rotateIp
                        })
                    });
                    
                    const result = await response.json();
                    handleUrlDistributionResult({
                        url: targetUrl,
                        devices: Object.keys(result.results || {}),
                        results: result.results || {}
                    });
                }
                
                // For immediate visual feedback
                const affectedDevices = targetDeviceIds || 
                    devices.map(d => d.id);
                
                affectedDevices.forEach(deviceId => {
                    let deviceCard = document.getElementById(`device-${deviceId}`);
                    if (deviceCard) {
                        let statusHeader = deviceCard.querySelector('.device-status h3 span');
                        if (statusHeader) {
                            statusHeader.textContent = '▶️ RUNNING';
                            statusHeader.className = 'status-running';
                        }
                    }
                });
                
                // Request updated statuses after a short delay
                setTimeout(requestAllDeviceStatuses, 1000);
            } catch (error) {
                log(`Error distributing URL: ${error}`, 'error');
            }
        }
        
        // Log to UI
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
            
            // Limit log entries
            const maxEntries = 100;
            while (logElement.children.length > maxEntries) {
                logElement.removeChild(logElement.firstChild);
            }
        }
        
        // Update status information for all devices
        function updateDeviceStatus(devicesStatus, updateAll = true) {
            if (!devicesStatus) return;
            
            if (updateAll) {
                devices.forEach(device => {
                    updateSingleDeviceStatus(device.id, device.status);
                });
            } else {
                Object.entries(devicesStatus).forEach(([deviceId, status]) => {
                    updateSingleDeviceStatus(deviceId, status);
                });
            }
        }
        
        // Update status for a single device
        function updateSingleDeviceStatus(deviceId, status) {
            if (!status) return;
            
            const deviceCard = document.getElementById(`device-${deviceId}`);
            if (!deviceCard) return;
            
            // Find or create status section
            let statusSection = deviceCard.querySelector('.device-status');
            if (!statusSection) {
                statusSection = document.createElement('div');
                statusSection.className = 'device-status';
                deviceCard.appendChild(statusSection);
            }
            
            // Format elapsed and remaining time
            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0s';
                seconds = Math.max(0, parseInt(seconds));
                
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) {
                    return `${hours}h ${minutes}m ${secs}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            };
            
            // Format URL for display
            const formatUrl = (url) => {
                if (!url) return 'No URL configured';
                // Truncate long URLs
                if (url.length > 40) {
                    return url.substring(0, 37) + '...';
                }
                return url;
            };
            
            // Determine status icon and class
            let statusIcon, statusClass;
            switch(status.status) {
                case 'running':
                    statusIcon = '▶️';
                    statusClass = 'status-running';
                    break;
                case 'paused':
                    statusIcon = '⏸️';
                    statusClass = 'status-paused';
                    break;
                case 'stopped':
                    statusIcon = '⏹️';
                    statusClass = 'status-stopped';
                    break;
                default:
                    statusIcon = '⚪';
                    statusClass = 'status-idle';
            }
            
            // Use defaults for missing values
            const currentIteration = Number(status.current_iteration) || 0;
            const totalIterations = Number(status.total_iterations) || 0;
            // Force percentage to be a number between 0-100
            let percentage = 0;
            if (totalIterations > 0 && currentIteration > 0) {
                percentage = Math.min(100, Math.max(0, (currentIteration / totalIterations) * 100));
            } else if (status.percentage) {
                percentage = Math.min(100, Math.max(0, Number(status.percentage) || 0));
            }
            
            // Make sure status has all required fields with defaults if missing
            const processedStatus = {
                device_id: deviceId,
                current_iteration: currentIteration,
                total_iterations: totalIterations,
                percentage: Math.round(percentage * 10) / 10, // Round to 1 decimal
                url: status.url || '',
                min_interval: Number(status.min_interval) || 0,
                max_interval: Number(status.max_interval) || 0,
                elapsed_time: Number(status.elapsed_time) || 0,
                estimated_remaining: Number(status.estimated_remaining) || 0,
                status: status.status || 'idle',
                is_running: status.is_running || false,
                delay_min: Number(status.delay_min) || 0,
                delay_max: Number(status.delay_max) || 0
            };
            
            // Log status data for debugging (only for significant changes)
            if (processedStatus.current_iteration > 0 && 
                (!window.lastLoggedStatus || 
                 window.lastLoggedStatus[deviceId]?.current_iteration !== processedStatus.current_iteration)) {
                
                console.log(`Device ${deviceId} status:`, processedStatus);
                
                if (!window.lastLoggedStatus) window.lastLoggedStatus = {};
                window.lastLoggedStatus[deviceId] = {...processedStatus};
            }
            
            // Format iterations progress
            const iterationsProgress = `${processedStatus.current_iteration}/${processedStatus.total_iterations} - ${processedStatus.percentage}%`;
            
            // Update status section
            if (processedStatus.current_iteration > 0 && processedStatus.total_iterations > 0) {
                // Simulation is active with progress
                statusSection.innerHTML = `
                    <h3>Simulation Status <span class="${statusClass}">${statusIcon} ${processedStatus.status.toUpperCase()}</span></h3>
                    <div class="status-info">
                        <div class="progress-bar-container">
                            <div class="progress-bar ${processedStatus.status === 'paused' ? 'paused' : ''}" style="width: ${processedStatus.percentage}%"></div>
                        </div>
                        
                        <div class="simulation-stats">
                            <div class="stat-item elapsed">
                                <div class="stat-label">ELAPSED</div>
                                <div class="stat-value">${formatTime(processedStatus.elapsed_time)}</div>
                            </div>
                            <div class="stat-item remaining">
                                <div class="stat-label">REMAINING</div>
                                <div class="stat-value">${formatTime(processedStatus.estimated_remaining)}</div>
                            </div>
                            <div class="stat-item iterations">
                                <div class="stat-label">PROGRESS</div>
                                <div class="stat-value">${iterationsProgress}</div>
                            </div>
                            <div class="stat-item interval">
                                <div class="stat-label">INTERVAL</div>
                                <div class="stat-value">${processedStatus.min_interval}-${processedStatus.max_interval}s</div>
                            </div>
                            <div class="stat-item delay">
                                <div class="stat-label">DELAY</div>
                                <div class="stat-value">${processedStatus.delay_min || 0}-${processedStatus.delay_max || 0}s</div>
                            </div>
                            <div class="stat-item url">
                                <div class="stat-label">URL</div>
                                <div class="stat-value" title="${processedStatus.url}">
                                    <span class="url-value">${formatUrl(processedStatus.url)}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // No active simulation
                statusSection.innerHTML = `
                    <h3>Simulation Status <span class="${statusClass}">${statusIcon} ${processedStatus.status.toUpperCase()}</span></h3>
                    <div class="status-info">
                        <div>No active simulation</div>
                        <div class="simulation-stats">
                            <div class="stat-item elapsed">
                                <div class="stat-label">ELAPSED</div>
                                <div class="stat-value">0s</div>
                            </div>
                            <div class="stat-item remaining">
                                <div class="stat-label">REMAINING</div>
                                <div class="stat-value">0s</div>
                            </div>
                            <div class="stat-item iterations">
                                <div class="stat-label">PROGRESS</div>
                                <div class="stat-value">0/0 - 0%</div>
                            </div>
                            <div class="stat-item interval">
                                <div class="stat-label">INTERVAL</div>
                                <div class="stat-value">0-0s</div>
                            </div>
                            <div class="stat-item delay">
                                <div class="stat-label">DELAY</div>
                                <div class="stat-value">1-2s</div>
                            </div>
                            <div class="stat-item url">
                                <div class="stat-label">URL</div>
                                <div class="stat-value">No URL configured</div>
                            </div>
                        </div>
                        <button class="btn" onclick="executeCommand('${processedStatus.device_id}', 'start')">Start New Simulation</button>
                    </div>
                `;
            }
        }
        
        // Handle device selection checkbox change
        function handleDeviceSelection(checkbox) {
            const deviceId = checkbox.getAttribute('data-device-id');
            const deviceCard = document.getElementById(`device-${deviceId}`);
            
            if (checkbox.checked) {
                deviceCard.classList.add('selected');
            } else {
                deviceCard.classList.remove('selected');
            }
            
            updateSelectionCount();
        }
        
        // Update selection counter and buttons
        function updateSelectionCount() {
            const checkboxes = document.querySelectorAll('.device-checkbox:checked');
            const count = checkboxes.length;
            const countElement = document.getElementById('selectionCount');
            
            countElement.textContent = `${count} device${count !== 1 ? 's' : ''} selected`;
            
            // Update action buttons state
            const actionButtons = [
                document.getElementById('startSelectedBtn'),
                document.getElementById('stopSelectedBtn'),
                document.getElementById('pauseSelectedBtn'),
                document.getElementById('resumeSelectedBtn')
            ];
            
            actionButtons.forEach(button => {
                button.disabled = count === 0;
            });
            
            // Update select all checkbox
            const selectAllCheckbox = document.getElementById('selectAllDevices');
            if (devices.length > 0 && count === devices.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else if (count === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.indeterminate = true;
            }
        }
        
        // Toggle all device checkboxes
        function toggleAllDevices(checked) {
            const checkboxes = document.querySelectorAll('.device-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
                const deviceId = checkbox.getAttribute('data-device-id');
                const deviceCard = document.getElementById(`device-${deviceId}`);
                
                if (checked) {
                    deviceCard.classList.add('selected');
                } else {
                    deviceCard.classList.remove('selected');
                }
            });
            
            updateSelectionCount();
        }
        
        // Get selected device IDs
        function getSelectedDeviceIds() {
            const checkboxes = document.querySelectorAll('.device-checkbox:checked');
            return Array.from(checkboxes).map(checkbox => checkbox.getAttribute('data-device-id'));
        }
        
        // Execute batch command on selected devices
        async function executeBatchCommand(command) {
            const selectedDeviceIds = getSelectedDeviceIds();
            
            if (selectedDeviceIds.length === 0) {
                log('No devices selected', 'warning');
                return;
            }
            
            log(`Executing '${command}' on ${selectedDeviceIds.length} selected devices...`, 'info');
            
            // Get parameters if command is start
            let params = {};
            if (command === 'start') {
                const targetUrl = document.getElementById('targetUrl').value;
                if (!targetUrl) {
                    log('Error: Target URL is required for start command', 'error');
                    return;
                }
                
                const iterations = parseInt(document.getElementById('iterations').value);
                const minInterval = parseInt(document.getElementById('minInterval').value);
                const maxInterval = parseInt(document.getElementById('maxInterval').value);
                const useWebview = document.getElementById('useWebview').checked;
                const rotateIp = document.getElementById('rotateIp').checked;
                
                params = {
                    url: targetUrl,
                    iterations: iterations,
                    min_interval: minInterval,
                    max_interval: maxInterval,
                    use_webview: useWebview,
                    rotate_ip: rotateIp
                };
                
                // For start commands, use the URL distribution functionality instead
                // as it provides better support for simulation parameters
                distributeUrlToDevices(targetUrl, selectedDeviceIds, iterations, minInterval, maxInterval, useWebview, rotateIp);
                return;
            }
            
            try {
                if (isWebSocketConnected) {
                    // Use WebSocket for batch commands
                    socket.send(JSON.stringify({
                        type: 'batch_command',
                        command: command,
                        device_ids: selectedDeviceIds,
                        parameters: params
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/devices/batch/command`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            command: command,
                            device_ids: selectedDeviceIds,
                            parameters: params
                        })
                    });
                    
                    const result = await response.json();
                    handleBatchCommandResult({
                        command: command,
                        results: result.results || {}
                    });
                }
                
                // For immediate visual feedback, update device statuses
                // This will be overridden by the actual status update when it arrives
                selectedDeviceIds.forEach(deviceId => {
                    let deviceCard = document.getElementById(`device-${deviceId}`);
                    if (deviceCard) {
                        let statusHeader = deviceCard.querySelector('.device-status h3 span');
                        if (statusHeader) {
                            let newStatus, newClass;
                            
                            switch (command) {
                                case 'stop':
                                    newStatus = '⏹️ STOPPED';
                                    newClass = 'status-stopped';
                                    break;
                                case 'pause':
                                    newStatus = '⏸️ PAUSED';
                                    newClass = 'status-paused';
                                    break;
                                case 'resume':
                                    newStatus = '▶️ RUNNING';
                                    newClass = 'status-running';
                                    break;
                            }
                            
                            if (newStatus && newClass) {
                                statusHeader.textContent = newStatus;
                                statusHeader.className = newClass;
                            }
                        }
                    }
                });
                
                // Request updated statuses for all devices
                setTimeout(requestAllDeviceStatuses, 1000);
            } catch (error) {
                log(`Error executing batch command: ${error}`, 'error');
            }
        }
        
        // Distribute URL to specific devices
        async function distributeUrlToDevices(url, deviceIds, iterations, minInterval, maxInterval, useWebview = true, rotateIp = true) {
            if (!url) {
                log('Error: URL is required', 'error');
                return;
            }
            
            if (!deviceIds || deviceIds.length === 0) {
                log('Error: No devices specified', 'error');
                return;
            }
            
            log(`Distributing URL '${url}' to ${deviceIds.length} devices...`, 'info');
            
            try {
                if (isWebSocketConnected) {
                    // Use WebSocket
                    socket.send(JSON.stringify({
                        type: 'distribute_url',
                        url: url,
                        device_ids: deviceIds,
                        iterations: iterations,
                        min_interval: minInterval,
                        max_interval: maxInterval,
                        use_webview: useWebview,
                        rotate_ip: rotateIp
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/distribute-url`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            url: url,
                            device_ids: deviceIds,
                            iterations: iterations,
                            min_interval: minInterval,
                            max_interval: maxInterval,
                            use_webview: useWebview,
                            rotate_ip: rotateIp
                        })
                    });
                    
                    const result = await response.json();
                    handleUrlDistributionResult({
                        url: url,
                        devices: deviceIds,
                        results: result.results || {}
                    });
                }
                
                // For immediate visual feedback
                deviceIds.forEach(deviceId => {
                    let deviceCard = document.getElementById(`device-${deviceId}`);
                    if (deviceCard) {
                        let statusHeader = deviceCard.querySelector('.device-status h3 span');
                        if (statusHeader) {
                            statusHeader.textContent = '▶️ RUNNING';
                            statusHeader.className = 'status-running';
                        }
                    }
                });
                
                // Request updated statuses after a short delay
                setTimeout(requestAllDeviceStatuses, 1000);
            } catch (error) {
                log(`Error distributing URL: ${error}`, 'error');
            }
        }
        
        // Request status updates for selected devices or all if none selected
        function requestSelectedDeviceStatuses() {
            const selectedDevices = getSelectedDevices();
            
            if (selectedDevices.length === 0) {
                // No devices selected, request all
                requestAllDeviceStatuses();
                log('Requesting status update for all devices', 'info');
            } else {
                // Request status for selected devices only
                log(`Requesting status update for ${selectedDevices.length} selected devices`, 'info');
                
                // Make individual requests for each device to avoid full overhead
                selectedDevices.forEach(deviceId => {
                    socket.send(JSON.stringify({
                        type: 'get_device_status',
                        device_id: deviceId
                    }));
                });
            }
        }
        
        // Request status updates for all devices
        function requestAllDeviceStatuses() {
            socket.send(JSON.stringify({
                type: 'get_status'
            }));
            log('Requesting status update for all devices', 'info');
        }
        
        // Configure server logging
        async function configureLogging() {
            const level = document.getElementById('loggingLevel').value;
            const quietAdb = document.getElementById('quietAdbMode').checked;
            
            // Target is 'all' for general logging or 'adb_controller' to just quiet ADB messages
            const target = quietAdb ? 'adb_controller' : 'all';
            const effectiveLevel = quietAdb ? 'WARNING' : level;
            
            log(`Setting log level to ${effectiveLevel} for ${target}...`, 'info');
            
            try {
                if (isWebSocketConnected) {
                    // Use WebSocket
                    socket.send(JSON.stringify({
                        type: 'configure_logging',
                        level: effectiveLevel,
                        target: target
                    }));
                } else {
                    // Fallback to HTTP API
                    const response = await fetch(`${API_URL}/logging/configure`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            level: effectiveLevel,
                            target: target
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        log(result.message, 'success');
                    } else {
                        log(`Failed to set logging level: ${result.detail || 'Unknown error'}`, 'error');
                    }
                }
            } catch (error) {
                log(`Error configuring logging: ${error}`, 'error');
            }
        }
        
        // Get current logging status
        async function getLoggingStatus() {
            try {
                const response = await fetch(`${API_URL}/logging/status`);
                const result = await response.json();
                
                if (result.status === 'success') {
                    const config = result.config;
                    
                    // Update UI to match current settings
                    const loggingLevelSelect = document.getElementById('loggingLevel');
                    const quietAdbMode = document.getElementById('quietAdbMode');
                    
                    // Set the logging level dropdown
                    if (config.root && loggingLevelSelect) {
                        loggingLevelSelect.value = config.root;
                    }
                    
                    // Set the quiet ADB mode checkbox
                    if (config.adb_controller && quietAdbMode) {
                        // If ADB controller's level is WARNING or higher, and different from root, it's in quiet mode
                        const adbLevel = config.adb_controller;
                        const isQuiet = (adbLevel === 'WARNING' || adbLevel === 'ERROR' || adbLevel === 'CRITICAL') &&
                                       adbLevel !== config.root;
                        quietAdbMode.checked = isQuiet;
                    }
                    
                    log(`Current log levels - Server: ${config.root}, ADB: ${config.adb_controller}`, 'info');
                }
            } catch (error) {
                console.error('Error getting logging status:', error);
            }
        }
        
        // Add handlers for status update controls
        function handleStatusUpdateConfig() {
            const automatic = document.getElementById('autoUpdateToggle').checked;
            const interval = parseInt(document.getElementById('updateIntervalSelect').value);
            
            log(`${automatic ? 'Enabling' : 'Disabling'} automatic updates with interval ${interval}s`, 'info');
            
            fetch(`${API_URL}/settings/status-updates`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    automatic: automatic,
                    interval: interval
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    log(data.message, 'success');
                } else {
                    log(`Failed to update settings: ${data.detail || 'Unknown error'}`, 'error');
                }
            })
            .catch(error => {
                log(`Error updating status settings: ${error}`, 'error');
            });
        }
        
        // Function to manually request status updates
        function requestManualStatusUpdate() {
            log('Manually requesting status update...', 'info');
            document.getElementById('manualUpdateBtn').disabled = true;
            document.getElementById('manualUpdateBtn').textContent = 'Updating...';
            
            fetch(`${API_URL}/devices/request-status`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    log(data.message, 'success');
                    updateLastUpdateTime();
                } else {
                    log(`Failed to update status: ${data.detail || 'Unknown error'}`, 'error');
                }
                document.getElementById('manualUpdateBtn').disabled = false;
                document.getElementById('manualUpdateBtn').textContent = 'Refresh Status';
            })
            .catch(error => {
                log(`Error requesting status update: ${error}`, 'error');
                document.getElementById('manualUpdateBtn').disabled = false;
                document.getElementById('manualUpdateBtn').textContent = 'Refresh Status';
            });
        }
        
        // Update the last update time display
        function updateLastUpdateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('lastUpdateTime').textContent = `Last updated: ${timeString}`;
        }
        
        // Get current status update configuration
        function getStatusUpdateConfig() {
            fetch(`${API_URL}/settings/status-updates`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const config = data.config;
                    document.getElementById('autoUpdateToggle').checked = config.automatic;
                    document.getElementById('updateIntervalSelect').value = config.interval.toString();
                    
                    log(`Status update config: automatic=${config.automatic}, interval=${formatInterval(config.interval)}`, 'info');
                }
            })
            .catch(error => {
                console.error('Error getting status update config:', error);
            });
        }
        
        // Format the interval for display
        function formatInterval(seconds) {
            if (seconds >= 3600) {
                return `${Math.floor(seconds / 3600)} hour(s)`;
            } else if (seconds >= 60) {
                return `${Math.floor(seconds / 60)} minute(s)`;
            } else {
                return `${seconds} seconds`;
            }
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Connect WebSocket
            connectWebSocket();
            
            // Don't request initial status update automatically
            // Removed automatic status update on page load to prevent device lag
            
            // Add event listeners
            document.getElementById('refreshDevicesBtn').addEventListener('click', getDevices);
            document.getElementById('urlDistributionForm').addEventListener('submit', distributeUrl);
            
            // Status update controls event listeners
            document.getElementById('autoUpdateToggle').addEventListener('change', handleStatusUpdateConfig);
            document.getElementById('updateIntervalSelect').addEventListener('change', handleStatusUpdateConfig);
            document.getElementById('manualUpdateBtn').addEventListener('click', requestManualStatusUpdate);
            
            // Device selection event listeners
            document.getElementById('selectAllDevices').addEventListener('change', function(e) {
                toggleAllDevices(e.target.checked);
            });
            
            document.getElementById('startSelectedBtn').addEventListener('click', function() {
                executeBatchCommand('start');
            });
            
            document.getElementById('stopSelectedBtn').addEventListener('click', function() {
                executeBatchCommand('stop');
            });
            
            document.getElementById('pauseSelectedBtn').addEventListener('click', function() {
                executeBatchCommand('pause');
            });
            
            document.getElementById('resumeSelectedBtn').addEventListener('click', function() {
                executeBatchCommand('resume');
            });
            
            // Logging control event listeners
            document.getElementById('setLoggingBtn').addEventListener('click', configureLogging);
            
            // Get initial logging status
            getLoggingStatus();
            
            // Get initial status update configuration
            getStatusUpdateConfig();
            
            // Initial log
            log('Dashboard initialized', 'info');
        });

        // Add refresh button event listener
        document.getElementById('refreshStatusBtn').addEventListener('click', function() {
            requestSelectedDeviceStatuses();
        });

        // Set up manual refresh button handler
        $('#manualUpdateBtn').click(function() {
            requestSelectedDeviceStatuses();
        });

        // Add SMS functions
        async function sendDataRenewalSMS(deviceId) {
            try {
                showToast(`Sending data renewal SMS from device ${deviceId}...`, 'info');
                
                const response = await fetch(`/devices/${deviceId}/renew-data`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showToast(`Data renewal SMS sent successfully`, 'success');
                } else {
                    showToast(`Error: ${result.detail || 'Failed to send data renewal SMS'}`, 'error');
                }
            } catch (error) {
                console.error('Error sending data renewal SMS:', error);
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        async function sendCustomSMS(deviceId) {
            try {
                const phoneNumber = document.getElementById(`sms-number-${deviceId}`).value.trim();
                const message = document.getElementById(`sms-message-${deviceId}`).value.trim();
                
                if (!phoneNumber || !message) {
                    showToast('Please enter both phone number and message', 'error');
                    return;
                }
                
                showToast(`Sending SMS to ${phoneNumber} from device ${deviceId}...`, 'info');
                
                const response = await fetch(`/devices/${deviceId}/send-sms`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        device_id: deviceId,
                        phone_number: phoneNumber,
                        message: message
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showToast(`SMS sent successfully to ${phoneNumber}`, 'success');
                } else {
                    showToast(`Error: ${result.detail || 'Failed to send SMS'}`, 'error');
                }
            } catch (error) {
                console.error('Error sending SMS:', error);
                showToast(`Error: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html> 